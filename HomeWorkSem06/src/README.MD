## Объектно-ориентированное программирование (семинары)
### Урок 6. ООП Дизайн и Solid
**Задание:**
***Рефакторинг и\или оптимизация проекта предыдущего дз ссылка =>
https://github.com/KuzminaElizavetaV/Java_OOP/tree/main/HomeWorkSem05 с учетом теоретических основ SOLID’а***

### Доработки проекта:

1. Проект реструктуризован с помощью пакетов, которые объединены общей логикой.

   - пакет **Infrastructure** представдляет Модель приложения, в нем добавилось 3 новых пакета: 
     - CalcComplexNumber содержит 4 компоненты (модели) на каждую операцию с комплексными числами, например,
     сложение, деление и т.д.
     - CalcRationalNumber содержит 4 компоненты (модели) на каждую операцию с комплексными числами аналогично пакету выше.
     Оба эти пакета проработаны во исполнение 1 и 2 принципов SOLID. При необходимости расширений не придется их менять,
     а можно будет дополнить, доработав немного компоненту управления связями Presenter.
     - OperationAll тоже содержит 4 компонены: перечисление операций (enum) OperationType, где перечислены все виды 
     операций, какие используются в моем проекте (сложение, вычитание, деление, умножение), абстрактный класс 
     OperationStorage, задача которого создание списка операций в виде словаря и вывод красивого пользовательского 
     консольного меню для выбора нужной операции на основе этого словаря. У этого класса 2 наследника: 
       - OperationStorageComplex (словарь операций для комплексных чисел)
       - OperationStorageRational (словарь операций для рациональных чисел)
       
     Эта идея появилась когда подумала, а вдруг потребуется добавить новую операцию, например, в калькулятор 
     рациональных чисел, я сделаю это очень быстро и легко: дополню enum новым значением операции, в пакете CalcRationalNumbers
     создам отдельную компоненту, где опишу логику расчета новой операции, в соответствующем классе Presenter добавлю в 
     словарь новую операцию, организую взаимодействие с пользователем.
     - интерфейс Model описывает стандартное поведение основной логики проекта
     - абстрактный класс CalcModel модель расчета - расширяется интерфейсом Model
     - класс ComplexNumber определяет операции над комплексными числами и формат вывода комлексного числа
     
   - пакет **Logger** содержит одну компоненту MyLoggerNew, которая описывает функционал логирования в проекте.
   
   - пакет **PresenterAll** (ранее он назывался MVP) содержит 4 компоненты: интерфейс I_Presenter описывает стандарное 
   поведение компоненты, которая связывает между собой компоненту взаимодействия с пользователем View и основную 
   логику Model, абстрактный класс PresenterCalc описывает компоненту связи Model и View между собой, расширяется 
   интерфейсом I_Presenter для реализации дочерними классами, 2 дочерних класса по типу данных:
     - PresenterCalcComplex (управление связью между Model и View для работы с комплексными числами)
     - PresenterCalcRational (управление связью между Model и View для работы с рациональными числами)
   Это все было сделано с целью ослабления зависимостей от деталей по 5 принципу SOLID.
     
   - пакет **UserInterface** (ранее назывался UI) содержит 4 компоненты: интерфейс View (взаимодействие с пользователем) 
   содержит методы для описания поведения получения-выдачи данных, в нем изменены 2 метода, класс ConsoleView 
   описывает взаимодействие с пользователем, имплементируя интерфейс View, класс App (запуск и главное меню приложения):
   в клиентском коде которого Presenter определяется методом setPresenter в зависимости от выбора и помещается в 
   переменную интерфейса I_Presenter, неважно какой там конкретно класс-наследник, метод buttonClick работает с любым,
   в связи с этим возможно расширение в дальнейшем - аналогично создается другой класс-наследник со своей логикой. 
   Изменен порядок работы с классом App. Из класса со статическими методами и полями он превратился в обычный класс, для
   работы с которым при запуске нужно создать экземпляр App. Сделано это для того, чтоб иметь возможность передать в 
   конструктор тип пользовательского интерфейса и не иметь сильную связь. Принцип инверсии зависимостей: экзепляр App 
   при создании может принять любой тип View и не ограничиваться ConsoleView, это облегчит расширяемость. К тому же App 
   сейчас польностью работает через View, никакого сканера или печати в консоль напрямую нет. Класс Main - это основная
   точка входа, в котором создается новый экземпляр приложения, передавая в конструктор тип View и запуск приложения.
2. Все классы соответствуют 3 и 4 принципу SOLID: реализуют одну и ту же логику, что и классы-родители и/или применяют
поведение интерфейсов, которые они реализуют.

3. Все компоненты снабжены документацией, что позволяет сторонним лицам быстрее понять, какой компонент за что отвечает.



